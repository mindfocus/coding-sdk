/*
CODING OPEN API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	. "github.com/mindfocus/coding-sdk/utils"
	. "github.com/mindfocus/coding-sdk/models"
	"io"
	"net/http"
	"net/url"
)


// WikiAPIService WikiAPI service
type WikiAPIService service

type ApiCreateUploadTokenRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	createUploadTokenRequest *CreateUploadTokenRequest
}

// 认证信息
func (r ApiCreateUploadTokenRequest) Authorization(authorization string) ApiCreateUploadTokenRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiCreateUploadTokenRequest) Action(action string) ApiCreateUploadTokenRequest {
	r.action = &action
	return r
}

func (r ApiCreateUploadTokenRequest) CreateUploadTokenRequest(createUploadTokenRequest CreateUploadTokenRequest) ApiCreateUploadTokenRequest {
	r.createUploadTokenRequest = &createUploadTokenRequest
	return r
}

func (r ApiCreateUploadTokenRequest) Execute() (*CreateUploadToken200Response, *http.Response, error) {
	return r.ApiService.CreateUploadTokenExecute(r)
}

/*
CreateUploadToken 上传文件的Token获取

✨ 获取上传文件的Token，成功后使用uploadLink 上传文件(ex:https://coding-net-test-self-1257242599.cos.ap-shanghai.myqcloud.com/b5d0d8e0-3aca-11eb-8673-a9b6d94ca755.png)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUploadTokenRequest
*/
func (a *WikiAPIService) CreateUploadToken(ctx context.Context) ApiCreateUploadTokenRequest {
	return ApiCreateUploadTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUploadToken200Response
func (a *WikiAPIService) CreateUploadTokenExecute(r ApiCreateUploadTokenRequest) (*CreateUploadToken200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUploadToken200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.CreateUploadToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=CreateUploadToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.createUploadTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWikiRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	createWikiRequest *CreateWikiRequest
}

// 认证信息
func (r ApiCreateWikiRequest) Authorization(authorization string) ApiCreateWikiRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiCreateWikiRequest) Action(action string) ApiCreateWikiRequest {
	r.action = &action
	return r
}

func (r ApiCreateWikiRequest) CreateWikiRequest(createWikiRequest CreateWikiRequest) ApiCreateWikiRequest {
	r.createWikiRequest = &createWikiRequest
	return r
}

func (r ApiCreateWikiRequest) Execute() (*CreateWiki200Response, *http.Response, error) {
	return r.ApiService.CreateWikiExecute(r)
}

/*
CreateWiki Wiki创建

✨ Wiki创建

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWikiRequest
*/
func (a *WikiAPIService) CreateWiki(ctx context.Context) ApiCreateWikiRequest {
	return ApiCreateWikiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWiki200Response
func (a *WikiAPIService) CreateWikiExecute(r ApiCreateWikiRequest) (*CreateWiki200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWiki200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.CreateWiki")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=CreateWiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.createWikiRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWikiByZipRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	createWikiByZipRequest *CreateWikiByZipRequest
}

// 认证信息
func (r ApiCreateWikiByZipRequest) Authorization(authorization string) ApiCreateWikiByZipRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiCreateWikiByZipRequest) Action(action string) ApiCreateWikiByZipRequest {
	r.action = &action
	return r
}

func (r ApiCreateWikiByZipRequest) CreateWikiByZipRequest(createWikiByZipRequest CreateWikiByZipRequest) ApiCreateWikiByZipRequest {
	r.createWikiByZipRequest = &createWikiByZipRequest
	return r
}

func (r ApiCreateWikiByZipRequest) Execute() (*CreateWikiByZip200Response, *http.Response, error) {
	return r.ApiService.CreateWikiByZipExecute(r)
}

/*
CreateWikiByZip Wiki 通过zip包上传

✨ 通过zip包上传wiki

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWikiByZipRequest
*/
func (a *WikiAPIService) CreateWikiByZip(ctx context.Context) ApiCreateWikiByZipRequest {
	return ApiCreateWikiByZipRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWikiByZip200Response
func (a *WikiAPIService) CreateWikiByZipExecute(r ApiCreateWikiByZipRequest) (*CreateWikiByZip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWikiByZip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.CreateWikiByZip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=CreateWikiByZip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.createWikiByZipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWikiRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	deleteWikiRequest *DeleteWikiRequest
}

// 认证信息
func (r ApiDeleteWikiRequest) Authorization(authorization string) ApiDeleteWikiRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiDeleteWikiRequest) Action(action string) ApiDeleteWikiRequest {
	r.action = &action
	return r
}

func (r ApiDeleteWikiRequest) DeleteWikiRequest(deleteWikiRequest DeleteWikiRequest) ApiDeleteWikiRequest {
	r.deleteWikiRequest = &deleteWikiRequest
	return r
}

func (r ApiDeleteWikiRequest) Execute() (*DeleteAPIDoc200Response, *http.Response, error) {
	return r.ApiService.DeleteWikiExecute(r)
}

/*
DeleteWiki Wiki 移至回收站

✨ 删除Wiki至回收站

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteWikiRequest
*/
func (a *WikiAPIService) DeleteWiki(ctx context.Context) ApiDeleteWikiRequest {
	return ApiDeleteWikiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAPIDoc200Response
func (a *WikiAPIService) DeleteWikiExecute(r ApiDeleteWikiRequest) (*DeleteAPIDoc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAPIDoc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.DeleteWiki")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=DeleteWiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.deleteWikiRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeImportJobStatusRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	describeImportJobStatusRequest *DescribeImportJobStatusRequest
}

// 认证信息
func (r ApiDescribeImportJobStatusRequest) Authorization(authorization string) ApiDescribeImportJobStatusRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiDescribeImportJobStatusRequest) Action(action string) ApiDescribeImportJobStatusRequest {
	r.action = &action
	return r
}

func (r ApiDescribeImportJobStatusRequest) DescribeImportJobStatusRequest(describeImportJobStatusRequest DescribeImportJobStatusRequest) ApiDescribeImportJobStatusRequest {
	r.describeImportJobStatusRequest = &describeImportJobStatusRequest
	return r
}

func (r ApiDescribeImportJobStatusRequest) Execute() (*DescribeImportJobStatus200Response, *http.Response, error) {
	return r.ApiService.DescribeImportJobStatusExecute(r)
}

/*
DescribeImportJobStatus zip包创建wiki的任务状态查询

✨ 通过zip包创建wiki任务状态查询

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeImportJobStatusRequest
*/
func (a *WikiAPIService) DescribeImportJobStatus(ctx context.Context) ApiDescribeImportJobStatusRequest {
	return ApiDescribeImportJobStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeImportJobStatus200Response
func (a *WikiAPIService) DescribeImportJobStatusExecute(r ApiDescribeImportJobStatusRequest) (*DescribeImportJobStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeImportJobStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.DescribeImportJobStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=DescribeImportJobStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.describeImportJobStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeUpdateJobStatusRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	describeImportJobStatusRequest *DescribeImportJobStatusRequest
}

// 认证信息
func (r ApiDescribeUpdateJobStatusRequest) Authorization(authorization string) ApiDescribeUpdateJobStatusRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiDescribeUpdateJobStatusRequest) Action(action string) ApiDescribeUpdateJobStatusRequest {
	r.action = &action
	return r
}

func (r ApiDescribeUpdateJobStatusRequest) DescribeImportJobStatusRequest(describeImportJobStatusRequest DescribeImportJobStatusRequest) ApiDescribeUpdateJobStatusRequest {
	r.describeImportJobStatusRequest = &describeImportJobStatusRequest
	return r
}

func (r ApiDescribeUpdateJobStatusRequest) Execute() (*DescribeImportJobStatus200Response, *http.Response, error) {
	return r.ApiService.DescribeUpdateJobStatusExecute(r)
}

/*
DescribeUpdateJobStatus zip包更新wiki的任务状态查询

✨ 通过zip包更新wiki任务状态查询

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeUpdateJobStatusRequest
*/
func (a *WikiAPIService) DescribeUpdateJobStatus(ctx context.Context) ApiDescribeUpdateJobStatusRequest {
	return ApiDescribeUpdateJobStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeImportJobStatus200Response
func (a *WikiAPIService) DescribeUpdateJobStatusExecute(r ApiDescribeUpdateJobStatusRequest) (*DescribeImportJobStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeImportJobStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.DescribeUpdateJobStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=DescribeUpdateJobStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.describeImportJobStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeWikiRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	describeWikiRequest *DescribeWikiRequest
}

// 认证信息
func (r ApiDescribeWikiRequest) Authorization(authorization string) ApiDescribeWikiRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiDescribeWikiRequest) Action(action string) ApiDescribeWikiRequest {
	r.action = &action
	return r
}

func (r ApiDescribeWikiRequest) DescribeWikiRequest(describeWikiRequest DescribeWikiRequest) ApiDescribeWikiRequest {
	r.describeWikiRequest = &describeWikiRequest
	return r
}

func (r ApiDescribeWikiRequest) Execute() (*ModifyWiki200Response, *http.Response, error) {
	return r.ApiService.DescribeWikiExecute(r)
}

/*
DescribeWiki Wiki 详情获取

✨ 获取Wiki详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeWikiRequest
*/
func (a *WikiAPIService) DescribeWiki(ctx context.Context) ApiDescribeWikiRequest {
	return ApiDescribeWikiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModifyWiki200Response
func (a *WikiAPIService) DescribeWikiExecute(r ApiDescribeWikiRequest) (*ModifyWiki200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModifyWiki200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.DescribeWiki")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=DescribeWiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.describeWikiRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDescribeWikiListRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	describeAPIDocListRequest *DescribeAPIDocListRequest
}

// 认证信息
func (r ApiDescribeWikiListRequest) Authorization(authorization string) ApiDescribeWikiListRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiDescribeWikiListRequest) Action(action string) ApiDescribeWikiListRequest {
	r.action = &action
	return r
}

func (r ApiDescribeWikiListRequest) DescribeAPIDocListRequest(describeAPIDocListRequest DescribeAPIDocListRequest) ApiDescribeWikiListRequest {
	r.describeAPIDocListRequest = &describeAPIDocListRequest
	return r
}

func (r ApiDescribeWikiListRequest) Execute() (*DescribeWikiList200Response, *http.Response, error) {
	return r.ApiService.DescribeWikiListExecute(r)
}

/*
DescribeWikiList Wiki 列表详情获取

✨ 获取Wiki列表详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDescribeWikiListRequest
*/
func (a *WikiAPIService) DescribeWikiList(ctx context.Context) ApiDescribeWikiListRequest {
	return ApiDescribeWikiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeWikiList200Response
func (a *WikiAPIService) DescribeWikiListExecute(r ApiDescribeWikiListRequest) (*DescribeWikiList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeWikiList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.DescribeWikiList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=DescribeWikiList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.describeAPIDocListRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyWikiRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	modifyWikiRequest *ModifyWikiRequest
}

// 认证信息
func (r ApiModifyWikiRequest) Authorization(authorization string) ApiModifyWikiRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiModifyWikiRequest) Action(action string) ApiModifyWikiRequest {
	r.action = &action
	return r
}

func (r ApiModifyWikiRequest) ModifyWikiRequest(modifyWikiRequest ModifyWikiRequest) ApiModifyWikiRequest {
	r.modifyWikiRequest = &modifyWikiRequest
	return r
}

func (r ApiModifyWikiRequest) Execute() (*ModifyWiki200Response, *http.Response, error) {
	return r.ApiService.ModifyWikiExecute(r)
}

/*
ModifyWiki Wiki 更新

✨ 更新Wiki

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModifyWikiRequest
*/
func (a *WikiAPIService) ModifyWiki(ctx context.Context) ApiModifyWikiRequest {
	return ApiModifyWikiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModifyWiki200Response
func (a *WikiAPIService) ModifyWikiExecute(r ApiModifyWikiRequest) (*ModifyWiki200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModifyWiki200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.ModifyWiki")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=ModifyWiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.modifyWikiRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyWikiByZipRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	modifyWikiByZipRequest *ModifyWikiByZipRequest
}

// 认证信息
func (r ApiModifyWikiByZipRequest) Authorization(authorization string) ApiModifyWikiByZipRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiModifyWikiByZipRequest) Action(action string) ApiModifyWikiByZipRequest {
	r.action = &action
	return r
}

func (r ApiModifyWikiByZipRequest) ModifyWikiByZipRequest(modifyWikiByZipRequest ModifyWikiByZipRequest) ApiModifyWikiByZipRequest {
	r.modifyWikiByZipRequest = &modifyWikiByZipRequest
	return r
}

func (r ApiModifyWikiByZipRequest) Execute() (*CreateWikiByZip200Response, *http.Response, error) {
	return r.ApiService.ModifyWikiByZipExecute(r)
}

/*
ModifyWikiByZip 通过zip包更新wiki

✨ 通过zip包更新wiki

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModifyWikiByZipRequest
*/
func (a *WikiAPIService) ModifyWikiByZip(ctx context.Context) ApiModifyWikiByZipRequest {
	return ApiModifyWikiByZipRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWikiByZip200Response
func (a *WikiAPIService) ModifyWikiByZipExecute(r ApiModifyWikiByZipRequest) (*CreateWikiByZip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWikiByZip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.ModifyWikiByZip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=ModifyWikiByZip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.modifyWikiByZipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyWikiOrderRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	modifyWikiOrderRequest *ModifyWikiOrderRequest
}

// 认证信息
func (r ApiModifyWikiOrderRequest) Authorization(authorization string) ApiModifyWikiOrderRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiModifyWikiOrderRequest) Action(action string) ApiModifyWikiOrderRequest {
	r.action = &action
	return r
}

func (r ApiModifyWikiOrderRequest) ModifyWikiOrderRequest(modifyWikiOrderRequest ModifyWikiOrderRequest) ApiModifyWikiOrderRequest {
	r.modifyWikiOrderRequest = &modifyWikiOrderRequest
	return r
}

func (r ApiModifyWikiOrderRequest) Execute() (*DeleteAPIDoc200Response, *http.Response, error) {
	return r.ApiService.ModifyWikiOrderExecute(r)
}

/*
ModifyWikiOrder Wiki 父级修改

✨ 修改wiki父级

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModifyWikiOrderRequest
*/
func (a *WikiAPIService) ModifyWikiOrder(ctx context.Context) ApiModifyWikiOrderRequest {
	return ApiModifyWikiOrderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAPIDoc200Response
func (a *WikiAPIService) ModifyWikiOrderExecute(r ApiModifyWikiOrderRequest) (*DeleteAPIDoc200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAPIDoc200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.ModifyWikiOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=ModifyWikiOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.modifyWikiOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyWikiTitleRequest struct {
	ctx context.Context
	ApiService *WikiAPIService
	authorization *string
	action *string
	modifyWikiTitleRequest *ModifyWikiTitleRequest
}

// 认证信息
func (r ApiModifyWikiTitleRequest) Authorization(authorization string) ApiModifyWikiTitleRequest {
	r.authorization = &authorization
	return r
}

// Action
func (r ApiModifyWikiTitleRequest) Action(action string) ApiModifyWikiTitleRequest {
	r.action = &action
	return r
}

func (r ApiModifyWikiTitleRequest) ModifyWikiTitleRequest(modifyWikiTitleRequest ModifyWikiTitleRequest) ApiModifyWikiTitleRequest {
	r.modifyWikiTitleRequest = &modifyWikiTitleRequest
	return r
}

func (r ApiModifyWikiTitleRequest) Execute() (*ModifyWikiTitle200Response, *http.Response, error) {
	return r.ApiService.ModifyWikiTitleExecute(r)
}

/*
ModifyWikiTitle Wiki 标题更新

✨ Wiki 标题更新

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModifyWikiTitleRequest
*/
func (a *WikiAPIService) ModifyWikiTitle(ctx context.Context) ApiModifyWikiTitleRequest {
	return ApiModifyWikiTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModifyWikiTitle200Response
func (a *WikiAPIService) ModifyWikiTitleExecute(r ApiModifyWikiTitleRequest) (*ModifyWikiTitle200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModifyWikiTitle200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiAPIService.ModifyWikiTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/?action=ModifyWikiTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, ReportError("authorization is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, ReportError("action is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Action", r.action, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.modifyWikiTitleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
